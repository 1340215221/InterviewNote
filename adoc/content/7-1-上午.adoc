
=== 7-1-上午


- 静态内部类单例
. 实现方法
.. 私有化对象的构造方法
.. 在对象静态内部类的静态成员变量中初始化一个对象实例
. 优点
.. 对象的实例作为一个静态资源被加载. 静态资源在加载时是线程安全的, 并且静态资源只会被加载一次
.. 外部类加载时, 内部类不需要立即加载. 可以让实例延迟创建, 没有被使用时不占用内存空间
+
[source,java]
----
include::../../maven/src/main/java/com/rh/code/design/singleton/StaticInnerClassWay.java[lines=6..17]
----
- 枚举单例
. 对比静态内部类单例实现, 依然可以使用反射调用构造方法去创建实例
. 枚举类默认构造方法为私有的, 并且无法通过反射去获取到构造方法
. 由JVM自动创建实例保证了线程安全, 并且还可以防止通过反射创建实例
+
[source,java]
----
include::../../maven/src/main/java/com/rh/code/design/singleton/EnumWay.java[lines=6..8]
----
- 介绍下B+树和红黑树
. 二叉树
.. 在极端情况下, 如果数字式顺序插入进去的, 二叉树就退化成了链表结构. +
树结构是通过降低深度来提高查询效率的, 所以需要对树的节点进行平衡
. 红黑树
.. 只有两个子节点
.. 如果树能整个加载到内存, 效率会比B树高
. B-树
.. 常用于文件系统索引
.. 每个节点都存储数据, 并且限制每个节点的子节点数
.. 查找时每次只加载一个节点到内存, 只读取一部分数据
.. 例如: 4路的B-树, 最多只能有4个子节点, 每个节点最多存储3个数
. B+数
.. 只有子叶节点存储数据.
.. 子叶节点用指针连成一个链表 +
遍历所有的子叶节点, 就可以遍历到所有的数据, 也方便查询一个区域的数据
- 反射原理
- ConcurrentHashMap1.7和1.8的区别 // todo
- HashMap在并发扩容时为什么会死循环
. HashMap在扩容时会重新设置节点指向关系, 多线程同时设置节点指向关系时相互影响, 造成有些节点连成一个环形链表
. tip
.. HashMap是由数组和链表组成的, 当扩容时会对所有元素`rehash`, 将元素移动到新的位置. 可能会降低链表的长度, 提高查询效率
- 讲一下泛型擦除
. java运行期间并不保存对象的泛型信息
. 可以通过反射给泛型为String的List添加一个数字, 而不会报错
. java会在编译期检查代码的泛型类型是否正确, 如果错误则会编译失败