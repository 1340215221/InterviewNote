

==== 设计原则


. OO基础
.. 抽象
. OO原则
.. 封装变化 +
找出程序中变化的方面, 然后将其和固定不变的方面相分离
.. 多用组合, 少用继承
.. 针对接口编程, 不针对实现编程
.. 为交互对象之间的松耦合设计而努力
.. 类应该对拓展开放, 对修改关闭
.. 要依赖抽象, 不要依赖具体(依赖倒置原则)
... 这里更强调 `抽象`
... 不能让高层组件依赖底层组件
... 高层组件和底层组件都应该依赖于抽象
... 依赖倒置思想
.... 需要从底层元素开始思考
.... 例如要建一个披萨店
..... 正常思维, 从上层向底层思考 +
我需要一个披萨店, 需要 _准备披萨/烘烤/装盒_, 披萨又分为 _芝士披萨/素食披萨_
..... 倒置思维, 从底层向上层思考 +
我需要有不同种类的披萨, 披萨共有特性可以抽取为一个抽象, 披萨店依赖于抽象披萨
... 可行原则
.... 变量不可以持有具体类的引用 +
如果使用new, 就会持有具体类的引用, 你可以用工厂来避免
.... 不要让类派生自具体类 +
如果派生自具体类, 就会依赖具体类, 请派生自一个接口或抽象类
.... 不要覆盖基类中已实现的方法 +
如果覆盖基类已实现的方法, 那么你的基类就不是一个真正适合被继承的抽象 +
基类中已实现的方法, 应该由所有的子类共享
. OO模式
.. 观察者模式
... 观察者模式定义了对象之间一对多的关系
... 主题和观察者之间用松耦合方式结合, 主题不知道观察者的细节,
只知道观察者实现了观察者接口
... 使用此设计模式时, 可以从主题处推或者拉数据
(然而, 推的方式被认为更为正确).
... 有许多的观察者时, 不可以依赖特定的通知次序
... 设计原则
.... 在观察者模式中, 会变的是主题的状态, 以及观察者的数量和类型. +
依赖主题状态的观察者改变时, 却不必改变主题
.... 主题和观察者之间都依赖对方的抽象接口, 具有松耦合, 不必对对方的实现有了解
.... 主题中组合了观察者对象


