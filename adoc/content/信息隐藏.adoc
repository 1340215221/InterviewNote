

==== 信息隐藏
当继承能简化设计时就继承 +
隐藏设计决策对于减少 `改动所影响的代码量` 而言至关重要 +
当你不知道怎么设计类时, 要自问: 我可以隐藏什么

.主要隐藏两种内容
* 隐藏复杂度 +
这样你就不用再去应付它, 除非你要特别关注的时候
* 隐藏变化源 +
这样当变化发生时, 其影响就能被限制在局部范围内

    例如:
    - 暴露一个 独立,内部可修改 的方法给其他地方使用, 便于当该方法需要修改时不必修改每个调用的地方
    - 返回的值也尽可能向上抽象. 提供返回值的原有功能不变, 又给方法提供方提供变化的余地


.信息隐藏障碍
* 信息过度分散
** 常量例子: 一个不可从内部变化的常量, 被使用的地方过于分散. 需要使用一个常量将它隐藏起来, 当需要修改时只需要改动一处即可
** 改变方式类型例子: 当约定或默认已知会使用一种操作方式, 最好将实际操作和操作类型进行隔离, 将具体操作类型的逻辑集中到单独的类或者子程序中.
这样在增加或改变操作类型时, 不会给系统带来全局性的影响
** 暴露过多细节的例子: 对调用者暴露太多它暂时并不需要的实现细节时, 它可能会利用这些细节, 慢慢你的实现会被调用方所使用的功能所固定下来, 难以改变
* 循环依赖
** _A类中的子程序调用了B类中的子程序, B类中的子程序调用了A类中的子程序. 此时系统难以测试, 无法单独测试其中一个类, 除非另一个已经部分准备就绪了_
* 把类内的数据误认为是全局数据
** 如果类内的数据作用范围仅在当前类中, 那么这个数据带来的风险要小得多. 如果它同时是一个全局的变量, 操作它同时将会带来很多意想不到的问题 +

    全局数据通常受困于两个问题:
    - 子程序操作全局数据时, 不知道还有那些子程序也在操作全局数据
    - 子程序知道那些其他子程序也在操作全局数据, 但不知道在进行什么操作

    使用类内数据解决上述两个问题:
    - 类内数据通过类内子程序进行包装, 提供操作入口. 使用类内数据的子程序和操作都在类里定义了
    - 如果类被设计得 体积庞大,包含众多子程序 的话, 类数据和全局数据的区别就变得模糊了, 类内数据也会受困于全局数据面临的问题

* 可察觉的性能损耗
** 试图在架构层和编码层均避免性能上的损耗

    架构层 & 编码层
    - 实际上, 架构层按照信息隐藏的目标进行设计并不会和按照性能目标设计相冲突
    - 担心的源头都来自于编码层. 等先做出来高模块化的东西后, 就可以对个别子程序进行优化而不会影响系统剩余部分了



