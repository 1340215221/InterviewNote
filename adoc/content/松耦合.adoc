

==== 松耦合
松耦合的关键在于, 一个有效的模块提供出了一层附加的抽象. +

    一旦你写好了它你就可以想当然的去使用它, 使你可以在同一时间只关注一件事

.高耦合的情况
* 方法参数过多, 参数数据量大
* _如果两个类都依赖于对方对同一个全局变量的使用情况_

    两个类共同协作操作同一个全局变量

.耦合标准
* 规模
** 参数数量少的方法, 与其调用方的耦合更为松散
** 公共方法越少的类, 与其调用方的耦合更为松散
* 可见性 +
指两个模块之间连接的显著程度
** 通过参数列表显示传递数据便是一种明显的连接
** 通过修改全局数据使另一个模块能够用到该数据, 则是一种 "鬼鬼祟祟" 的做法

    不得已要使用全局数据通信时, 需要在文档中做好说明

* 灵活性 +
指模块之间的连接是否容易改动 +
一个模块越容易被调用, 便是越灵活. 尽可能缩短互相的连接

    灵活性也会受到上面几个条件的影响:
    - 现有一个开发需要调用用户服务查询用户名字 CompanyService.getUsers(User user) , 需要传入的参数只有 `companyId, userIds`.
    - 实际在调用接口时, 需要临时拼凑一个只有两个字段的 `User` 对象, 这就需要调用者对 `getUsers` 的内部实现有所了解
    - 使这个接口变得更友好的办法是, 修改这个方法的入参为只需要传入 `companyId, userIds` 这两个参数
    ! 这是我自己举的例子, 可能很不恰当, 这确实是一个需要调用者对方法内部实现有了解才能使用方法的例子.
    但这种设计本身就是为了把所有user的筛选条件处理逻辑统一到 `getUsers` 这个方法中, 便于统一管理和灵活拓展

.耦合种类
* 简单数据参数耦合
** 两个模块只通过参数来传递数据, 并且数据都是基本数据类型.

    这种耦合是很正常的

* 简单对象耦合
** 一个模块中实例化一个对象.

    这种耦合也很正常

* 对象参数耦合
** beanA要求beanB传给它一个beanC.

    这就要求beanB要对beanC了解

* 语义耦合
** _一个模块不仅使用了另一个模块的语法元素, 而且还是用了有关那个模块内部工作细节的语义知识_

    例子1:
    - moduleA向moduleB传递了一个控制标识, 通过它告诉该怎么做.
    这已经要求moduleA要了解moduleB对这个标识的使用.
    = 这里应该把控制标识定义为枚举类型或对象

    例子2:
    - moduleA在moduleB修改了某个全局数据后使用该全局数据.
    这就要求moduleB的修改符合moduleA的需要, 并且moduleB已经在恰当的时机被调用过了
    = 共同操作同一份数据, modeuleB的修改在时机和操作内容上, 与modeuleA没有严格的关系和控制. 不能直接从代码上看出modeuleB的修改什么时候对modeuleA的那一部分会有影响. 甚至说无法看出modeuleB的修改对谁有影响

    例子3:
    - modeuleA使用时要求, 必须先调用 init(), 再调用 run(). modeuleB知道 run() 无论如何都会调用 init(), 所以modeuleB没有调用 modeuleA.init(), 就直接调用 modeuleA.run()

    例子4:
    - modeuleA在使用modeuleB时需要传一个bean, modeuleA知道modeuleB只是用了bean的7个方法中的三个, 所以modeuleA在初始化bean时, 只初始化了bean中那三个方法所需的数据

    例子5:
    - 调用modeuleA需要一个IBean, modeuleB调用modeuleA传入一个beanImpl. 由于modeuleA知道实际modeuleB传入的是beanImpl, 所以将IBean强转为beanImpl, 并使用了beanImpl的特有方法

+
[WARNING]
====
如果在一次修改中破坏了被调用模块的语义耦合, 这种错误是无法被编译器发现的. +
出现错误的地方与被修改的地方看起来毫无关系, 调试非常困难
====

