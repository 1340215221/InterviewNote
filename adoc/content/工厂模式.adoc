

==== 工厂模式


. 将对象的创建和调用对象方法分离, 返回接口提供方法的调用
. 如果对象的创建较为复杂, 或者根据变量值创建不同的对象. +
可以将创建对象部分代码抽取到单独的类中, 便于复用. +
代码的调用方法也不再需要了解对象的创建详情
. 把工厂定义为一个静态方法如何 +
使用静态工厂不需要实例化工厂对象. +
但是, 静态工程不能通过继承改变创建方法行为. (降低了拓展能力)
. 简单工厂不是设计模式, 是一个编程习惯


. 简单工厂
.. 返回对象的抽象, 将创建具体对象的职责放到了工厂的成员方法中, +
这使得工厂客户端不需要对具体对象有了解. +
添加具体对象和修改具体对象的变化, 也被独立到工厂中了.
.. 成员方法中创建对象, 便于通过继承修改方法行为
. 工厂方法
.. 定义
... 定义了一个创建对象的接口, 但由子类决定实例化的类是哪一个.
工厂方法让类把实例化推迟到子类
.. 模型
... Creator类是创建者父类, 所有的产品都要实现Product
+
[source,java]
----
class Creator {
    abstract Product factoryMethod(String type)
----

.. 实例化职责被移到一个方法中, 此方法就如同一个工厂
.. 工厂方法抽象的, 所以依赖子类来处理对象的创建
.. 工厂方法必须返回一个产品, 可以通过传参来指定所需要的产品
.. 具体的对象创建封装到子类中,
从而将客户(调用对象方法的代码)和实例化具体对象的代码分隔开