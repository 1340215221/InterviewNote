

==== 类的加载


.类加载过程
. 加载
.. 通过一个类的全限定名来获取其定义的二进制字节流
.. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
.. 在Java堆中生成一个代表这个类的Class对象,
作为对方法区中这些数据的访问入口
. 连接
.. 验证阶段,
确保Class文件的字节流中包含的信息符合当前虚拟机的要求,
并且不会危害虚拟机自身的安全. 分为4个验证: +
_文件格式验证/元数据验证/字节码验证/符号引用验证_ +
验证阶段非常重要, 但不是必须的. 可以通过配置关闭, 以缩短虚拟机类加载时间
.. 准备阶段,
为类的静态变量分配内存, 并将内存初始化零值
.. 解析阶段,
将常量池内的符号引用替换为直接引用的过程. 针对7类符号引用进行 +
_类/接口/字段/类方法/接口方法/方法类型/方法句柄/调用点限定符_
... 符号引用, 就是一组符号来描述目标, 可以是任何字面量
... 直接引用, 就是 _直接指向目标的指针/相对偏移量/一个间接定位到目标的句柄
. 初始化类的静态变量为Java可用的值,
执行静态代码块


.加载器层级
. Bootstrap ClassLoader
根加载器 +
加载Java核心类
. Extension ClassLoader
拓展加载器 +
加载路径是JDK目录下jre/lib/ext +
由于根加载器并不是由Java实现的, 调用拓展加载器的getParent()返回的是null
. System ClassLoader
系统类加载器 +
加载路径是程序运行的当前路径


.双亲委派
. 当前ClassLoader首先从自己已加载的类中, 查找是否此类已加载,
如果已经加载则直接返回原来已经加载的类

 每个类加载器都有自己的加载缓存, 当一个类被加载了以后就会放入缓存中,
等下次加载时候就可以直接返回了

. 当前ClassLoader的缓存中没有找到被加载的类的时候
.. 委托父类加载器去加载, 父类加载器采用同样的策略, 首先查看自己的缓存,
然后委托父类去加载, 一直到bootstrap ClassLoader
.. 当所有的父类加载器都没有加载的时候, 再由当前的类加载器加载, 
并将其放入它自己的缓存中, 以便下次有加载请求的时候直接返回


.为什么优先使用父类加载器
. 共享功能 +
避免重复加载
. 隔离功能 +
避免用户自己编写的类替换Java核心类 +
全类名相同时, 如果使用的类加载器不同, 加载出来的类也不同 +
因为每次加载时都会创建一个新的Class实例