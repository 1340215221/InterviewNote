

==== 垃圾回收


. 主要对堆内存进行垃圾回收
. 堆内存分为老年代和新生代
.. 新生代又分为 Eden/Survivor0/Survivor1, 默认比例为8:1:1
. 新生代对象存活率低, 采用复制算法 +
老年代中对象存活率高, 采用标记整理法
. 垃圾回收分新生代MinorGC和老年代FullGC
.. MinorGC仅当Eden区满时触发, 仅回收新生代
.. FullGC当老年代满时触发, 会回收老年代和新生代


.回收算法
. 标记清除法
.. 从GC Root开始搜索, 标记所有被引用的对象
.. 未被标记过的对象为垃圾对象
.. 缺点
... 清理后存在大量不连续内存
... 效率低
. 标记整理法
.. 标记后, 将存活的对象移动到内存的一端. 移动完成后, 清理边界外的内存
.. 解决了内存清理后内存不连续的问题
.. 效率 依然很低
. 复制法
.. 将内存划分为两块, 每次只用其中一块
.. 当一块内存用完后, 将这块内存中所有存活的对象复制到另一块并移动指针,
然后清理这块内存
.. 也解决了内存不连续的情况
.. 缺点:
... 浪费了一半的内存
... 存活对象较多时, 效率低


.垃圾回收时机
对象分配内存时;;
. 如果对象过大, 直接进入老年代 +
避免大对象在内存之间的拷贝
. 正常情况, 对象优先进入Eden区
. 如果Eden内存不足, 则将Eden中所有存活对象拷贝到Survivor0中,
并清理Eden内存
. 如果Survivor0内存不足, 则将Eden和Survivor0中所有存活的对象拷贝到Survivor1,
清理Eden和Survivor0的内存
. 如果Survivor1内存也不足, 会通过配置检查是否能分配担保.
如果可以, 新生代所有存活对象将进入老年代, 并清理新生代内存


.那些对象会进入老年代 ?
. 每个对象都有一个年龄计数器.
当对象年龄在达到阈值时, 就会进入老年代. +
默认MaxTenuringThreshold = 15
. 对象在进入Survivor之后, 每经历一次MinorGC都会使年龄加1
. 大对象直接进入老年代
. 如果Survivor中相同年龄的对象达到了Survivor的一半,
那么大于或等于该年龄的对象就会直接进入老年代


.永久代
. 用于存储Class和Method元信息
. 不占堆内存, 由虚拟机直接分配
. 一般设置为128M, 设置原则是预留30%的空间
. 永久代满后触发FullGC, 而且会导致Class和Method元信息卸载