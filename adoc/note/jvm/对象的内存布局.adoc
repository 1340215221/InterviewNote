

=== 对象的内存布局


.对象的内存布局
. 对象头
.. 对象头分为两部分
... 对象自身运行时数据 +
哈希码, GC分代年龄, 锁状态标识, 线程持有锁, 偏向线程ID, 偏向时间戳
... 类型指针 +
对象指向它的类元数据的指针 +
虚拟机通过这个指针确定这个对象是哪个类的实例 +
并不是所有的虚拟机实现都必须在对象数据上保留类型指针. 换句话说, 查找对象的元数据并不一定要经过对象本身
.. 如果对象是一个Java数组, 对象头中还必须有一块用于记录数组长度的数据 +
因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大小, 但是从数组的元数据中无法确定数组大小
. 实例数据
.. 在代码中定义的各种字段的内容. +
无论是从父类集成的, 还是在子类中定义的
.. 存储顺序会受到虚拟机默认的分配策略和字段在Java源码中定义的顺序的影响
... 虚拟机的默认分配策略
.... 类型顺序 +
longs/doubles, ints, shorts/chars, bytes/booleans, oops（OrdinaryObjectPointers） +
从分配策略中可以看出, 相同宽度的字段总是会被分配到一起
.... 满足类型顺序的前提下, 在父类中定义的变量会出现在子类之前
... 虚拟机设置CompactFields参数为true +
那么子类中较窄的变量也可能会插入到父类变量的空隙中
. 对齐填充
对齐填充并不是必然存在的, 起着占位符的作用 +
HotSpotVM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍. 换句话说, 对象大小必须是8字节的证书倍 +
对象头刚好是8字节的倍数(1倍或2倍), 当实例数据部分没有对齐时, 需要通过对齐填充来补全
