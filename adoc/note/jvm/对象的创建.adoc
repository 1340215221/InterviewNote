

=== 对象的创建
仅限普通对象, 不包括数组和Class对象

. 虚拟机遇到一条new指令时
.. 先去检查这个指令的参数, 是否能在常量池中定位到一个类的符号引用.
.. 检查符号引用代表的类是否已经被加载解析初始化过了. +
如果没有, 必须先执行相应的 `类的加载过程`.
.. 虚拟机为新生对象分配内存 +
对象所需内存大小在类加载完成后便可完全确定 +
`内存分配` 的两种方式
分配内存中的线程安全问题
.. 分配的内存空间初始化零值 +
内存分配完成后, 虚拟机需要将分配到的内存空间都初始化为零值 +
不包括对象头 +
如果使用了TLAB, 可以将这一工作提前至TLAB分配时进行
... 该操作保证了, 对象实例字段在Java代码中可以不赋初始值就直接使用 +
程序能访问到这些字段的数据类型对应的零值
+
 将分配的内存初始化为Java类型对应的零值

.. 设置对象信息, 并存储到对象头中 +
对象是那个类的实例,
如何才能找到元数据信息,
对象的哈希码,
对象的GC分代年龄 +
根据虚拟机的状态不同, 对象头会有不同的设置方式
.. 执行对象的<init>方法, 初始化对象


. 内存分配方式
.. 指针碰撞 +
假设Java堆中的内存绝对规整, 用过的内存放在一边, 空闲的内存放在另一边, 中间放着一个指针作为分界点的指示器 +
那所分配的内存就仅仅是把那个指针向空闲内存那边挪动一段与对象大小相等的距离
.. 空闲列表 +
如果Java堆中内存并不规整, 已使用内存和空闲内存相互交错, 虚拟机必须维护一个列表, 记录上哪些内存块可用 +
在分配内存时, 从列表找一块足够大的空间划分给对象实例, 并更新列表上的记录
. 使用选择
.. 选择取决于Java堆是否规整 +
Java堆是否规整, 取决于采用的垃圾回收器是否带有压缩整理功能
... 使用Serial和ParNew等带Compact过程的收集器时, 分配算法采用指针碰撞
... 使用CMS基于Mark-Sweep算法的收集器时, 分配算法采用空闲列表


. 虚拟机内存分配并发处理
.. 对分配内存操作进行同步处理 +
虚拟机采用CAS加失败重试, 保证了更新操作的原子性
.. 创建 本地线程分配缓冲区(TLAB) +
把内存分配动作按照线程划分在不同的空间中进行
... 每个线程在堆中预先分配一小块内存 +
那个线程需要分配内存, 就在那个线程的TLAB上分配 +
只有TLAB用完并分配新的TLAB时, 才需要同步锁定
. 虚拟机是否使用TLAB配置参数 +
-XX：+/-UseTLAB

